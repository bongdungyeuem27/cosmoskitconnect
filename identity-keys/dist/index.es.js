import*as d from"@noble/ed25519";import{verifySignature as b}from"@cosmoskitconnect/cacao";import{Store as k}from"@cosmoskitconnect/core";import{generateJWT as $,objectToHex as x,encodeEd25519Key as h,composeDidPkh as u,jwtExp as f}from"@cosmoskitconnect/did-jwt";import{generateRandomBytes32 as p,formatMessage as w}from"@cosmoskitconnect/utils";import g from"axios";const v="https://keys.walletconnect.com",E="wc@2:identityKeys:";class H{constructor(t,i,r){this.core=t,this.projectId=i,this.init=async()=>{await this.identityKeys.init()},this.generateIdAuth=async(e,s)=>{const{identityKeyPub:a,identityKeyPriv:n}=this.identityKeys.get(e);return $([a,n],s)},this.generateIdentityKey=()=>{const e=d.utils.randomPrivateKey();return this.getKeyData(e)},this.getKeyHex=e=>d.utils.bytesToHex(e).toLowerCase(),this.getKeyData=async e=>{const s=await d.getPublicKey(e);return{publicKey:s,privateKey:e,pubKeyHex:this.getKeyHex(s),privKeyHex:this.getKeyHex(e)}},this.keyserverUrl=r??v,this.identityKeys=new k(t,this.core.logger,"identityKeys",E,e=>e.accountId)}isRegistered(t){return this.identityKeys.keys.includes(t)}async prepareRegistrationWithRecaps({domain:t,recapObject:i}){const r=`urn:recap:${x(i)}`,{pubKeyHex:e,privateKey:s}=await this.generateIdentityKey(),a=h(e),n=`https://${t}?walletconnect_identity_key=${a}`;return{cacaoPayload:{aud:n,uri:n,statement:void 0,domain:t,nonce:p(),iat:new Date().toISOString(),version:"1",resources:[this.keyserverUrl,r]},privateIdentityKey:s}}async prepareRegistration({domain:t,accountId:i,statement:r}){const{privateKey:e,pubKeyHex:s}=await this.generateIdentityKey(),a={aud:h(s),statement:r,domain:t,iss:u(i),nonce:p(),iat:new Date().toISOString(),version:"1",resources:[this.keyserverUrl]};return{message:w(a,u(i)),registerParams:{cacaoPayload:a,privateIdentityKey:e}}}async registerIdentity({registerParams:t,signature:i}){const r=t.cacaoPayload.iss.split(":").slice(-3).join(":");if(this.isRegistered(r))return this.identityKeys.get(r).identityKeyPub;try{const e=w(t.cacaoPayload,t.cacaoPayload.iss);if(!i.s)throw new Error(`Provided an invalid signature. Expected a string but got: ${i.s}`);const[s,a,n]=r.split(":"),y=`Provided an invalid signature. Signature ${i.s} of type ${i.t} by account ${r} is not a valid signature for message ${e}`;let o=!1;try{o=await b(n,e,i,`${s}:${a}`,this.projectId)}catch{o=!1}if(!o)throw new Error(y);const I=`${this.keyserverUrl}/identity`,P={h:{t:"eip4361"},p:t.cacaoPayload,s:i};try{await g.post(I,{cacao:P})}catch(K){throw new Error(`Failed to register on keyserver: ${K}`)}const{pubKeyHex:c,privKeyHex:l}=await this.getKeyData(t.privateIdentityKey);return await this.core.crypto.keychain.set(c,l),await this.identityKeys.set(r,{identityKeyPriv:l,identityKeyPub:c,accountId:r}),c}catch(e){throw this.core.logger.error(e),e}}async unregisterIdentity({account:t}){try{const i=Date.now(),r=this.identityKeys.get(t),e=u(t),s={iat:i,exp:f(i),iss:h(r.identityKeyPub),aud:this.keyserverUrl,pkh:e,act:"unregister_identity",sub:"identity_keys"},a=await this.generateIdAuth(t,s),n=`${this.keyserverUrl}/identity`,y=await g.delete(n,{data:{idAuth:a}});if(y.status!==200)throw new Error(`Failed to unregister on keyserver ${y.status}`);await this.identityKeys.delete(t,{code:-1,message:`Account ${t} unregistered`})}catch(i){throw this.core.logger.error(i),i}}async resolveIdentity({publicKey:t}){const i=`${this.keyserverUrl}/identity?publicKey=${t.split(":")[2]}`;try{const{data:r}=await g.get(i);return r.value.cacao}catch(r){throw this.core.logger.error(r),new Error("Failed to resolve identity key")}}async getIdentity({account:t}){return this.identityKeys.get(t).identityKeyPub}async hasIdentity({account:t}){return this.identityKeys.keys.includes(t)}}class R{}export{v as DEFAULT_KEYSERVER_URL,R as IIdentityKeys,H as IdentityKeys};
//# sourceMappingURL=index.es.js.map

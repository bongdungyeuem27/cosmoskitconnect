import{createStorage as I}from"unstorage";import{createStore as p,get as l,set as g,del as b,keys as v,clear as S}from"idb-keyval";import{safeJsonStringify as y,safeJsonParse as d}from"@cosmoskitconnect/safe-json";function T(i){return i}const x="idb-keyval";var z=(i={})=>{const t=i.base&&i.base.length>0?`${i.base}:`:"",e=a=>t+a;let n;return i.dbName&&i.storeName&&(n=p(i.dbName,i.storeName)),{name:x,options:i,async hasItem(a){return await l(e(a),n)!==void 0},async getItem(a){return await l(e(a),n)??null},async getItemRaw(a){return await l(e(a),n)??null},setItem(a,s){return g(e(a),s,n)},setItemRaw(a,s){return g(e(a),s,n)},removeItem(a){return b(e(a),n)},getKeys(){return v(n)},clear(){return S(n)}}};const D="WALLET_CONNECT_V2_INDEXED_DB",E="keyvaluestorage";class _{constructor(){this.indexedDb=I({driver:z({dbName:D,storeName:E})})}async getKeys(){return this.indexedDb.getKeys()}async getEntries(){return(await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(t=>[t.key,t.value])}async getItem(t){const e=await this.indexedDb.getItem(t);if(e!==null)return e}async setItem(t,e){await this.indexedDb.setItem(t,y(e))}async removeItem(t){await this.indexedDb.removeItem(t)}}var m=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},c={exports:{}};(function(){let i;function t(){}i=t,i.prototype.getItem=function(e){return this.hasOwnProperty(e)?String(this[e]):null},i.prototype.setItem=function(e,n){this[e]=String(n)},i.prototype.removeItem=function(e){delete this[e]},i.prototype.clear=function(){const e=this;Object.keys(e).forEach(function(n){e[n]=void 0,delete e[n]})},i.prototype.key=function(e){return e=e||0,Object.keys(this)[e]},i.prototype.__defineGetter__("length",function(){return Object.keys(this).length}),typeof m<"u"&&m.localStorage?c.exports=m.localStorage:typeof window<"u"&&window.localStorage?c.exports=window.localStorage:c.exports=new t})();function k(i){var t;return[i[0],d((t=i[1])!=null?t:"")]}class K{constructor(){this.localStorage=c.exports}async getKeys(){return Object.keys(this.localStorage)}async getEntries(){return Object.entries(this.localStorage).map(k)}async getItem(t){const e=this.localStorage.getItem(t);if(e!==null)return d(e)}async setItem(t,e){this.localStorage.setItem(t,y(e))}async removeItem(t){this.localStorage.removeItem(t)}}const N="wc_storage_version",h=1,O=async(i,t,e)=>{const n=N,a=await t.getItem(n);if(a&&a>=h){e(t);return}const s=await i.getKeys();if(!s.length){e(t);return}const u=[];for(;s.length;){const r=s.shift();if(!r)continue;const o=r.toLowerCase();if(o.includes("wc@")||o.includes("walletconnect")||o.includes("wc_")||o.includes("wallet_connect")){const w=await i.getItem(r);await t.setItem(r,w),u.push(r)}}await t.setItem(n,h),e(t),j(i,u)},j=async(i,t)=>{t.length&&t.forEach(async e=>{await i.removeItem(e)})};class f{constructor(){this.initialized=!1,this.setInitialized=e=>{this.storage=e,this.initialized=!0};const t=new K;this.storage=t;try{const e=new _;O(t,e,this.setInitialized)}catch{this.initialized=!0}}async getKeys(){return await this.initialize(),this.storage.getKeys()}async getEntries(){return await this.initialize(),this.storage.getEntries()}async getItem(t){return await this.initialize(),this.storage.getItem(t)}async setItem(t,e){return await this.initialize(),this.storage.setItem(t,e)}async removeItem(t){return await this.initialize(),this.storage.removeItem(t)}async initialize(){this.initialized||await new Promise(t=>{const e=setInterval(()=>{this.initialized&&(clearInterval(e),t())},20)})}}export{f as KeyValueStorage,f as default};
//# sourceMappingURL=index.es.js.map

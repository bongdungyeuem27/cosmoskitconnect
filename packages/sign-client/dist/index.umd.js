(function(f,g){typeof exports=="object"&&typeof module<"u"?g(exports,require("@cosmoskitconnect/core"),require("@cosmoskitconnect/types"),require("@cosmoskitconnect/utils")):typeof define=="function"&&define.amd?define(["exports","@cosmoskitconnect/core","@cosmoskitconnect/types","@cosmoskitconnect/utils"],g):(f=typeof globalThis<"u"?globalThis:f||self,g(f["@cosmoskitconnect/sign-client"]={},f.core,f.types,f.utils))})(this,function(f,g,Ae,o){"use strict";function Tt(n){try{return JSON.stringify(n)}catch{return'"[Circular]"'}}var It=Nt;function Nt(n,s,e){var t=e&&e.stringify||Tt,i=1;if(typeof n=="object"&&n!==null){var r=s.length+i;if(r===1)return n;var a=new Array(r);a[0]=t(n);for(var l=1;l<r;l++)a[l]=t(s[l]);return a.join(" ")}if(typeof n!="string")return n;var c=s.length;if(c===0)return n;for(var h="",u=1-i,d=-1,y=n&&n.length||0,p=0;p<y;){if(n.charCodeAt(p)===37&&p+1<y){switch(d=d>-1?d:0,n.charCodeAt(p+1)){case 100:case 102:if(u>=c||s[u]==null)break;d<p&&(h+=n.slice(d,p)),h+=Number(s[u]),d=p+2,p++;break;case 105:if(u>=c||s[u]==null)break;d<p&&(h+=n.slice(d,p)),h+=Math.floor(Number(s[u])),d=p+2,p++;break;case 79:case 111:case 106:if(u>=c||s[u]===void 0)break;d<p&&(h+=n.slice(d,p));var E=typeof s[u];if(E==="string"){h+="'"+s[u]+"'",d=p+2,p++;break}if(E==="function"){h+=s[u].name||"<anonymous>",d=p+2,p++;break}h+=t(s[u]),d=p+2,p++;break;case 115:if(u>=c)break;d<p&&(h+=n.slice(d,p)),h+=String(s[u]),d=p+2,p++;break;case 37:d<p&&(h+=n.slice(d,p)),h+="%",d=p+2,p++,u--;break}++u}++p}return d===-1?n:(d<y&&(h+=n.slice(d)),h)}const Le=It;var Ot=V;const H=kt().console||{},Pt={mapHttpRequest:se,mapHttpResponse:se,wrapRequestSerializer:fe,wrapResponseSerializer:fe,wrapErrorSerializer:fe,req:se,res:se,err:Ct};function qt(n,s){return Array.isArray(n)?n.filter(function(t){return t!=="!stdSerializers.err"}):n===!0?Object.keys(s):!1}function V(n){n=n||{},n.browser=n.browser||{};const s=n.browser.transmit;if(s&&typeof s.send!="function")throw Error("pino: transmit option must have a send function");const e=n.browser.write||H;n.browser.write&&(n.browser.asObject=!0);const t=n.serializers||{},i=qt(n.browser.serialize,t);let r=n.browser.serialize;Array.isArray(n.browser.serialize)&&n.browser.serialize.indexOf("!stdSerializers.err")>-1&&(r=!1);const a=["error","fatal","warn","info","debug","trace"];typeof e=="function"&&(e.error=e.fatal=e.warn=e.info=e.debug=e.trace=e),n.enabled===!1&&(n.level="silent");const l=n.level||"info",c=Object.create(e);c.log||(c.log=Y),Object.defineProperty(c,"levelVal",{get:u}),Object.defineProperty(c,"level",{get:d,set:y});const h={transmit:s,serialize:i,asObject:n.browser.asObject,levels:a,timestamp:Vt(n)};c.levels=V.levels,c.level=l,c.setMaxListeners=c.getMaxListeners=c.emit=c.addListener=c.on=c.prependListener=c.once=c.prependOnceListener=c.removeListener=c.removeAllListeners=c.listeners=c.listenerCount=c.eventNames=c.write=c.flush=Y,c.serializers=t,c._serialize=i,c._stdErrSerialize=r,c.child=p,s&&(c._logEvent=ye());function u(){return this.level==="silent"?1/0:this.levels.values[this.level]}function d(){return this._level}function y(E){if(E!=="silent"&&!this.levels.values[E])throw Error("unknown level "+E);this._level=E,G(h,c,"error","log"),G(h,c,"fatal","error"),G(h,c,"warn","error"),G(h,c,"info","log"),G(h,c,"debug","log"),G(h,c,"trace","log")}function p(E,w){if(!E)throw new Error("missing bindings for child Pino");w=w||{},i&&E.serializers&&(w.serializers=E.serializers);const _=w.serializers;if(i&&_){var S=Object.assign({},t,_),R=n.browser.serialize===!0?Object.keys(S):i;delete E.serializers,ie([E],R,S,this._stdErrSerialize)}function A(m){this._childLevel=(m._childLevel|0)+1,this.error=z(m,E,"error"),this.fatal=z(m,E,"fatal"),this.warn=z(m,E,"warn"),this.info=z(m,E,"info"),this.debug=z(m,E,"debug"),this.trace=z(m,E,"trace"),S&&(this.serializers=S,this._serialize=R),s&&(this._logEvent=ye([].concat(m._logEvent.bindings,E)))}return A.prototype=this,new A(this)}return c}V.levels={values:{fatal:60,error:50,warn:40,info:30,debug:20,trace:10},labels:{10:"trace",20:"debug",30:"info",40:"warn",50:"error",60:"fatal"}},V.stdSerializers=Pt,V.stdTimeFunctions=Object.assign({},{nullTime:Ce,epochTime:Ve,unixTime:xt,isoTime:Dt});function G(n,s,e,t){const i=Object.getPrototypeOf(s);s[e]=s.levelVal>s.levels.values[e]?Y:i[e]?i[e]:H[e]||H[t]||Y,bt(n,s,e)}function bt(n,s,e){!n.transmit&&s[e]===Y||(s[e]=function(t){return function(){const r=n.timestamp(),a=new Array(arguments.length),l=Object.getPrototypeOf&&Object.getPrototypeOf(this)===H?H:this;for(var c=0;c<a.length;c++)a[c]=arguments[c];if(n.serialize&&!n.asObject&&ie(a,this._serialize,this.serializers,this._stdErrSerialize),n.asObject?t.call(l,At(this,e,a,r)):t.apply(l,a),n.transmit){const h=n.transmit.level||s.level,u=V.levels.values[h],d=V.levels.values[e];if(d<u)return;Lt(this,{ts:r,methodLevel:e,methodValue:d,transmitLevel:h,transmitValue:V.levels.values[n.transmit.level||s.level],send:n.transmit.send,val:s.levelVal},a)}}}(s[e]))}function At(n,s,e,t){n._serialize&&ie(e,n._serialize,n.serializers,n._stdErrSerialize);const i=e.slice();let r=i[0];const a={};t&&(a.time=t),a.level=V.levels.values[s];let l=(n._childLevel|0)+1;if(l<1&&(l=1),r!==null&&typeof r=="object"){for(;l--&&typeof i[0]=="object";)Object.assign(a,i.shift());r=i.length?Le(i.shift(),i):void 0}else typeof r=="string"&&(r=Le(i.shift(),i));return r!==void 0&&(a.msg=r),a}function ie(n,s,e,t){for(const i in n)if(t&&n[i]instanceof Error)n[i]=V.stdSerializers.err(n[i]);else if(typeof n[i]=="object"&&!Array.isArray(n[i]))for(const r in n[i])s&&s.indexOf(r)>-1&&r in e&&(n[i][r]=e[r](n[i][r]))}function z(n,s,e){return function(){const t=new Array(1+arguments.length);t[0]=s;for(var i=1;i<t.length;i++)t[i]=arguments[i-1];return n[e].apply(this,t)}}function Lt(n,s,e){const t=s.send,i=s.ts,r=s.methodLevel,a=s.methodValue,l=s.val,c=n._logEvent.bindings;ie(e,n._serialize||Object.keys(n.serializers),n.serializers,n._stdErrSerialize===void 0?!0:n._stdErrSerialize),n._logEvent.ts=i,n._logEvent.messages=e.filter(function(h){return c.indexOf(h)===-1}),n._logEvent.level.label=r,n._logEvent.level.value=a,t(r,n._logEvent,l),n._logEvent=ye(c)}function ye(n){return{ts:0,messages:[],bindings:n||[],level:{label:"",value:0}}}function Ct(n){const s={type:n.constructor.name,msg:n.message,stack:n.stack};for(const e in n)s[e]===void 0&&(s[e]=n[e]);return s}function Vt(n){return typeof n.timestamp=="function"?n.timestamp:n.timestamp===!1?Ce:Ve}function se(){return{}}function fe(n){return n}function Y(){}function Ce(){return!1}function Ve(){return Date.now()}function xt(){return Math.round(Date.now()/1e3)}function Dt(){return new Date(Date.now()).toISOString()}function kt(){function n(s){return typeof s<"u"&&s}try{return typeof globalThis<"u"||Object.defineProperty(Object.prototype,"globalThis",{get:function(){return delete Object.prototype.globalThis,this.globalThis=this},configurable:!0}),globalThis}catch{return n(self)||n(window)||n(this)||{}}}const Mt={level:"info"},Q="custom_context";var Ut=Object.defineProperty,jt=Object.defineProperties,$t=Object.getOwnPropertyDescriptors,xe=Object.getOwnPropertySymbols,Kt=Object.prototype.hasOwnProperty,Gt=Object.prototype.propertyIsEnumerable,De=(n,s,e)=>s in n?Ut(n,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[s]=e,zt=(n,s)=>{for(var e in s||(s={}))Kt.call(s,e)&&De(n,e,s[e]);if(xe)for(var e of xe(s))Gt.call(s,e)&&De(n,e,s[e]);return n},Ft=(n,s)=>jt(n,$t(s));function Ht(n){return Ft(zt({},n),{level:n?.level||Mt.level})}function Yt(n,s=Q){return n[s]||""}function Qt(n,s,e=Q){return n[e]=s,n}function ke(n,s=Q){let e="";return typeof n.bindings>"u"?e=Yt(n,s):e=n.bindings().context||"",e}function Xt(n,s,e=Q){const t=ke(n,e);return t.trim()?`${t}/${s}`:s}function Bt(n,s,e=Q){const t=Xt(n,s,e),i=n.child({context:t});return Qt(i,t,e)}const Jt=1e3,Me=1,q=300,Ue=3600,M=86400,je=604800,Wt=2592e3;function me(n){return n*Jt}var ne={exports:{}},F=typeof Reflect=="object"?Reflect:null,$e=F&&typeof F.apply=="function"?F.apply:function(s,e,t){return Function.prototype.apply.call(s,e,t)},re;F&&typeof F.ownKeys=="function"?re=F.ownKeys:Object.getOwnPropertySymbols?re=function(s){return Object.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s))}:re=function(s){return Object.getOwnPropertyNames(s)};function Zt(n){console&&console.warn&&console.warn(n)}var Ke=Number.isNaN||function(s){return s!==s};function v(){v.init.call(this)}ne.exports=v,ne.exports.once=si,v.EventEmitter=v,v.prototype._events=void 0,v.prototype._eventsCount=0,v.prototype._maxListeners=void 0;var Ge=10;function oe(n){if(typeof n!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n)}Object.defineProperty(v,"defaultMaxListeners",{enumerable:!0,get:function(){return Ge},set:function(n){if(typeof n!="number"||n<0||Ke(n))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+n+".");Ge=n}}),v.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},v.prototype.setMaxListeners=function(s){if(typeof s!="number"||s<0||Ke(s))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+s+".");return this._maxListeners=s,this};function ze(n){return n._maxListeners===void 0?v.defaultMaxListeners:n._maxListeners}v.prototype.getMaxListeners=function(){return ze(this)},v.prototype.emit=function(s){for(var e=[],t=1;t<arguments.length;t++)e.push(arguments[t]);var i=s==="error",r=this._events;if(r!==void 0)i=i&&r.error===void 0;else if(!i)return!1;if(i){var a;if(e.length>0&&(a=e[0]),a instanceof Error)throw a;var l=new Error("Unhandled error."+(a?" ("+a.message+")":""));throw l.context=a,l}var c=r[s];if(c===void 0)return!1;if(typeof c=="function")$e(c,this,e);else for(var h=c.length,u=Xe(c,h),t=0;t<h;++t)$e(u[t],this,e);return!0};function Fe(n,s,e,t){var i,r,a;if(oe(e),r=n._events,r===void 0?(r=n._events=Object.create(null),n._eventsCount=0):(r.newListener!==void 0&&(n.emit("newListener",s,e.listener?e.listener:e),r=n._events),a=r[s]),a===void 0)a=r[s]=e,++n._eventsCount;else if(typeof a=="function"?a=r[s]=t?[e,a]:[a,e]:t?a.unshift(e):a.push(e),i=ze(n),i>0&&a.length>i&&!a.warned){a.warned=!0;var l=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(s)+" listeners added. Use emitter.setMaxListeners() to increase limit");l.name="MaxListenersExceededWarning",l.emitter=n,l.type=s,l.count=a.length,Zt(l)}return n}v.prototype.addListener=function(s,e){return Fe(this,s,e,!1)},v.prototype.on=v.prototype.addListener,v.prototype.prependListener=function(s,e){return Fe(this,s,e,!0)};function ei(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function He(n,s,e){var t={fired:!1,wrapFn:void 0,target:n,type:s,listener:e},i=ei.bind(t);return i.listener=e,t.wrapFn=i,i}v.prototype.once=function(s,e){return oe(e),this.on(s,He(this,s,e)),this},v.prototype.prependOnceListener=function(s,e){return oe(e),this.prependListener(s,He(this,s,e)),this},v.prototype.removeListener=function(s,e){var t,i,r,a,l;if(oe(e),i=this._events,i===void 0)return this;if(t=i[s],t===void 0)return this;if(t===e||t.listener===e)--this._eventsCount===0?this._events=Object.create(null):(delete i[s],i.removeListener&&this.emit("removeListener",s,t.listener||e));else if(typeof t!="function"){for(r=-1,a=t.length-1;a>=0;a--)if(t[a]===e||t[a].listener===e){l=t[a].listener,r=a;break}if(r<0)return this;r===0?t.shift():ti(t,r),t.length===1&&(i[s]=t[0]),i.removeListener!==void 0&&this.emit("removeListener",s,l||e)}return this},v.prototype.off=v.prototype.removeListener,v.prototype.removeAllListeners=function(s){var e,t,i;if(t=this._events,t===void 0)return this;if(t.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):t[s]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete t[s]),this;if(arguments.length===0){var r=Object.keys(t),a;for(i=0;i<r.length;++i)a=r[i],a!=="removeListener"&&this.removeAllListeners(a);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(e=t[s],typeof e=="function")this.removeListener(s,e);else if(e!==void 0)for(i=e.length-1;i>=0;i--)this.removeListener(s,e[i]);return this};function Ye(n,s,e){var t=n._events;if(t===void 0)return[];var i=t[s];return i===void 0?[]:typeof i=="function"?e?[i.listener||i]:[i]:e?ii(i):Xe(i,i.length)}v.prototype.listeners=function(s){return Ye(this,s,!0)},v.prototype.rawListeners=function(s){return Ye(this,s,!1)},v.listenerCount=function(n,s){return typeof n.listenerCount=="function"?n.listenerCount(s):Qe.call(n,s)},v.prototype.listenerCount=Qe;function Qe(n){var s=this._events;if(s!==void 0){var e=s[n];if(typeof e=="function")return 1;if(e!==void 0)return e.length}return 0}v.prototype.eventNames=function(){return this._eventsCount>0?re(this._events):[]};function Xe(n,s){for(var e=new Array(s),t=0;t<s;++t)e[t]=n[t];return e}function ti(n,s){for(;s+1<n.length;s++)n[s]=n[s+1];n.pop()}function ii(n){for(var s=new Array(n.length),e=0;e<s.length;++e)s[e]=n[e].listener||n[e];return s}function si(n,s){return new Promise(function(e,t){function i(a){n.removeListener(s,r),t(a)}function r(){typeof n.removeListener=="function"&&n.removeListener("error",i),e([].slice.call(arguments))}Be(n,s,r,{once:!0}),s!=="error"&&ni(n,i,{once:!0})})}function ni(n,s,e){typeof n.on=="function"&&Be(n,"error",s,e)}function Be(n,s,e,t){if(typeof n.on=="function")t.once?n.once(s,e):n.on(s,e);else if(typeof n.addEventListener=="function")n.addEventListener(s,function i(r){t.once&&n.removeEventListener(s,i),e(r)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof n)}const _e="wc",we=2,Se="client",ae=`${_e}@${we}:${Se}:`,ce={name:Se,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"},ri={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire"},oi={database:":memory:"},ve="cosmos-kit@2:WALLETCONNECT_DEEPLINK_CHOICE",ai={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},ci="history",li="0.3",Je="proposal",hi=Wt,We="Proposal expired",Ze="session",j=je,et="engine",N={wc_sessionPropose:{req:{ttl:q,prompt:!0,tag:1100},res:{ttl:q,prompt:!1,tag:1101},reject:{ttl:q,prompt:!1,tag:1120},autoReject:{ttl:q,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:q,prompt:!1,tag:1102},res:{ttl:q,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:M,prompt:!1,tag:1104},res:{ttl:M,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:M,prompt:!1,tag:1106},res:{ttl:M,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:q,prompt:!0,tag:1108},res:{ttl:q,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:q,prompt:!0,tag:1110},res:{ttl:q,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:M,prompt:!1,tag:1112},res:{ttl:M,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:M,prompt:!1,tag:1114},res:{ttl:M,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:Ue,prompt:!0,tag:1116},res:{ttl:Ue,prompt:!1,tag:1117},reject:{ttl:q,prompt:!1,tag:1118},autoReject:{ttl:q,prompt:!1,tag:1119}}},le={min:q,max:je},L={idle:"IDLE",active:"ACTIVE"},tt="request",it=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],st="wc",pi=1.5,nt="auth",rt="authKeys",ot="pairingTopics",at="requests",X=`${st}@${1.5}:${nt}:`,B=`${X}:PUB_KEY`,di="PARSE_ERROR",ui="INVALID_REQUEST",gi="METHOD_NOT_FOUND",Ei="INVALID_PARAMS",ct="INTERNAL_ERROR",Re="SERVER_ERROR",yi=[-32700,-32600,-32601,-32602,-32603],J={[di]:{code:-32700,message:"Parse error"},[ui]:{code:-32600,message:"Invalid Request"},[gi]:{code:-32601,message:"Method not found"},[Ei]:{code:-32602,message:"Invalid params"},[ct]:{code:-32603,message:"Internal error"},[Re]:{code:-32e3,message:"Server error"}},lt=Re;function fi(n){return yi.includes(n)}function ht(n){return Object.keys(J).includes(n)?J[n]:J[lt]}function mi(n){return Object.values(J).find(s=>s.code===n)||J[lt]}var _i=Object.defineProperty,wi=Object.defineProperties,Si=Object.getOwnPropertyDescriptors,pt=Object.getOwnPropertySymbols,vi=Object.prototype.hasOwnProperty,Ri=Object.prototype.propertyIsEnumerable,dt=(n,s,e)=>s in n?_i(n,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[s]=e,Ti=(n,s)=>{for(var e in s||(s={}))vi.call(s,e)&&dt(n,e,s[e]);if(pt)for(var e of pt(s))Ri.call(s,e)&&dt(n,e,s[e]);return n},Ii=(n,s)=>wi(n,Si(s));class ut{constructor(s){this.i=1;const e=s===8?new Uint8Array(1):s===16?new Uint16Array(1):new Uint32Array(1);this.initialValue=crypto.getRandomValues(e)[0]}getNextValue(){return this.initialValue+this.i++}}const Ni=new ut(8),Oi=new ut(16);function U(){const n=Date.now()*1e3,s=Ni.getNextValue();return n+s}function he(){const n=BigInt(Date.now())*BigInt(1e6),s=BigInt(Oi.getNextValue());return n+s}function pe(n,s,e){return{id:e||U(),jsonrpc:"2.0",method:n,params:s}}function Pi(n,s){return{id:n,jsonrpc:"2.0",result:s}}function qi(n,s,e){return{id:n,jsonrpc:"2.0",error:bi(s,e)}}function bi(n,s){return typeof n>"u"?ht(ct):(typeof n=="string"&&(n=Ii(Ti({},ht(Re)),{message:n})),typeof s<"u"&&(n.data=s),fi(n.code)&&(n=mi(n.code)),n)}function gt(n){return typeof n=="object"&&"id"in n&&"jsonrpc"in n&&n.jsonrpc==="2.0"}function Ai(n){return gt(n)&&"method"in n}function Li(n){return gt(n)&&(D(n)||k(n))}function D(n){return"result"in n}function k(n){return"error"in n}var Ci=Object.defineProperty,Vi=Object.defineProperties,xi=Object.getOwnPropertyDescriptors,Et=Object.getOwnPropertySymbols,Di=Object.prototype.hasOwnProperty,ki=Object.prototype.propertyIsEnumerable,yt=(n,s,e)=>s in n?Ci(n,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[s]=e,I=(n,s)=>{for(var e in s||(s={}))Di.call(s,e)&&yt(n,e,s[e]);if(Et)for(var e of Et(s))ki.call(s,e)&&yt(n,e,s[e]);return n},C=(n,s)=>Vi(n,xi(s));class Mi extends Ae.IEngine{constructor(s){super(s),this.name=et,this.events=new ne.exports,this.initialized=!1,this.requestQueue={state:L.idle,queue:[]},this.sessionRequestQueue={state:L.idle,queue:[]},this.requestQueueDelay=Me,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.relayMessageCache=[],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(N)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},me(this.requestQueueDelay)))},this.connect=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const t=C(I({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(t);const{pairingTopic:i,requiredNamespaces:r,optionalNamespaces:a,sessionProperties:l,relays:c}=t;let h=i,u,d=!1;try{h&&(d=this.client.core.pairing.pairings.get(h).active)}catch(m){throw this.client.logger.error(`connect() -> pairing.get(${h}) failed`),m}if(!h||!d){const{topic:m,uri:T}=await this.client.core.pairing.create();h=m,u=T}if(!h){const{message:m}=o.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${h}`);throw new Error(m)}const y=await this.client.core.crypto.generateKeyPair(),p=N.wc_sessionPropose.req.ttl||q,E=o.calcExpiry(p),w=I({requiredNamespaces:r,optionalNamespaces:a,relays:c??[{protocol:g.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:y,metadata:this.client.metadata},expiryTimestamp:E,pairingTopic:h},l&&{sessionProperties:l}),{reject:_,resolve:S,done:R}=o.createDelayedPromise(p,We);this.events.once(o.engineEvent("session_connect"),async({error:m,session:T})=>{if(m)_(m);else if(T){T.self.publicKey=y;const x=C(I({},T),{pairingTopic:w.pairingTopic,requiredNamespaces:w.requiredNamespaces,optionalNamespaces:w.optionalNamespaces,transportType:g.TRANSPORT_TYPES.relay});await this.client.session.set(T.topic,x),await this.setExpiry(T.topic,T.expiry),h&&await this.client.core.pairing.updateMetadata({topic:h,metadata:T.peer.metadata}),this.cleanupDuplicatePairings(x),S(x)}});const A=await this.sendRequest({topic:h,method:"wc_sessionPropose",params:w,throwOnFailedPublish:!0});return await this.setProposal(A,I({id:A},w)),{uri:u,approval:R}},this.pair=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(e)}catch(t){throw this.client.logger.error("pair() failed"),t}},this.approve=async e=>{var t,i,r;const a=this.client.core.eventClient.createEvent({properties:{topic:(t=e?.id)==null?void 0:t.toString(),trace:[g.EVENT_CLIENT_SESSION_TRACES.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(P){throw a.setError(g.EVENT_CLIENT_SESSION_ERRORS.no_internet_connection),P}try{await this.isValidProposalId(e?.id)}catch(P){throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`),a.setError(g.EVENT_CLIENT_SESSION_ERRORS.proposal_not_found),P}try{await this.isValidApprove(e)}catch(P){throw this.client.logger.error("approve() -> isValidApprove() failed"),a.setError(g.EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure),P}const{id:l,relayProtocol:c,namespaces:h,sessionProperties:u,sessionConfig:d}=e,y=this.client.proposal.get(l);this.client.core.eventClient.deleteEvent({eventId:a.eventId});const{pairingTopic:p,proposer:E,requiredNamespaces:w,optionalNamespaces:_}=y;let S=(i=this.client.core.eventClient)==null?void 0:i.getEvent({topic:p});S||(S=(r=this.client.core.eventClient)==null?void 0:r.createEvent({type:g.EVENT_CLIENT_SESSION_TRACES.session_approve_started,properties:{topic:p,trace:[g.EVENT_CLIENT_SESSION_TRACES.session_approve_started,g.EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success]}}));const R=await this.client.core.crypto.generateKeyPair(),A=E.publicKey,m=await this.client.core.crypto.generateSharedKey(R,A),T=I(I({relay:{protocol:c??"irn"},namespaces:h,controller:{publicKey:R,metadata:this.client.metadata},expiry:o.calcExpiry(j)},u&&{sessionProperties:u}),d&&{sessionConfig:d}),x=g.TRANSPORT_TYPES.relay;S.addTrace(g.EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);try{await this.client.core.relayer.subscribe(m,{transportType:x})}catch(P){throw S.setError(g.EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure),P}S.addTrace(g.EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);const W=C(I({},T),{topic:m,requiredNamespaces:w,optionalNamespaces:_,pairingTopic:p,acknowledged:!1,self:T.controller,peer:{publicKey:E.publicKey,metadata:E.metadata},controller:R,transportType:g.TRANSPORT_TYPES.relay});await this.client.session.set(m,W),S.addTrace(g.EVENT_CLIENT_SESSION_TRACES.store_session);try{S.addTrace(g.EVENT_CLIENT_SESSION_TRACES.publishing_session_settle),await this.sendRequest({topic:m,method:"wc_sessionSettle",params:T,throwOnFailedPublish:!0}).catch(P=>{throw S?.setError(g.EVENT_CLIENT_SESSION_ERRORS.session_settle_publish_failure),P}),S.addTrace(g.EVENT_CLIENT_SESSION_TRACES.session_settle_publish_success),S.addTrace(g.EVENT_CLIENT_SESSION_TRACES.publishing_session_approve),await this.sendResult({id:l,topic:p,result:{relay:{protocol:c??"irn"},responderPublicKey:R},throwOnFailedPublish:!0}).catch(P=>{throw S?.setError(g.EVENT_CLIENT_SESSION_ERRORS.session_approve_publish_failure),P}),S.addTrace(g.EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success)}catch(P){throw this.client.logger.error(P),this.client.session.delete(m,o.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(m),P}return this.client.core.eventClient.deleteEvent({eventId:S.eventId}),await this.client.core.pairing.updateMetadata({topic:p,metadata:E.metadata}),await this.client.proposal.delete(l,o.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:p}),await this.setExpiry(m,o.calcExpiry(j)),{topic:m,acknowledged:()=>Promise.resolve(this.client.session.get(m))}},this.reject=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(e)}catch(a){throw this.client.logger.error("reject() -> isValidReject() failed"),a}const{id:t,reason:i}=e;let r;try{r=this.client.proposal.get(t).pairingTopic}catch(a){throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`),a}r&&(await this.sendError({id:t,topic:r,error:i,rpcOpts:N.wc_sessionPropose.reject}),await this.client.proposal.delete(t,o.getSdkError("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(e)}catch(d){throw this.client.logger.error("update() -> isValidUpdate() failed"),d}const{topic:t,namespaces:i}=e,{done:r,resolve:a,reject:l}=o.createDelayedPromise(),c=U(),h=he().toString(),u=this.client.session.get(t).namespaces;return this.events.once(o.engineEvent("session_update",c),({error:d})=>{d?l(d):a()}),await this.client.session.update(t,{namespaces:i}),await this.sendRequest({topic:t,method:"wc_sessionUpdate",params:{namespaces:i},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:h}).catch(d=>{this.client.logger.error(d),this.client.session.update(t,{namespaces:u}),l(d)}),{acknowledged:r}},this.extend=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(e)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:t}=e,i=U(),{done:r,resolve:a,reject:l}=o.createDelayedPromise();return this.events.once(o.engineEvent("session_extend",i),({error:c})=>{c?l(c):a()}),await this.setExpiry(t,o.calcExpiry(j)),this.sendRequest({topic:t,method:"wc_sessionExtend",params:{},clientRpcId:i,throwOnFailedPublish:!0}).catch(c=>{l(c)}),{acknowledged:r}},this.request=async e=>{this.isInitialized();try{await this.isValidRequest(e)}catch(E){throw this.client.logger.error("request() -> isValidRequest() failed"),E}const{chainId:t,request:i,topic:r,expiry:a=N.wc_sessionRequest.req.ttl}=e,l=this.client.session.get(r);l?.transportType===g.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=U(),h=he().toString(),{done:u,resolve:d,reject:y}=o.createDelayedPromise(a,"Request expired. Please try again.");this.events.once(o.engineEvent("session_request",c),({error:E,result:w})=>{E?y(E):d(w)});const p=this.getAppLinkIfEnabled(l.peer.metadata,l.transportType);return p?(await this.sendRequest({clientRpcId:c,relayRpcId:h,topic:r,method:"wc_sessionRequest",params:{request:C(I({},i),{expiryTimestamp:o.calcExpiry(a)}),chainId:t},expiry:a,throwOnFailedPublish:!0,appLink:p}).catch(E=>y(E)),this.client.events.emit("session_request_sent",{topic:r,request:i,chainId:t,id:c}),await u()):await Promise.all([new Promise(async E=>{await this.sendRequest({clientRpcId:c,relayRpcId:h,topic:r,method:"wc_sessionRequest",params:{request:C(I({},i),{expiryTimestamp:o.calcExpiry(a)}),chainId:t},expiry:a,throwOnFailedPublish:!0}).catch(w=>y(w)),this.client.events.emit("session_request_sent",{topic:r,request:i,chainId:t,id:c}),E()}),new Promise(async E=>{var w;if(!((w=l.sessionConfig)!=null&&w.disableDeepLink)){const _=await o.getDeepLink(this.client.core.storage,ve);await o.handleDeeplinkRedirect({id:c,topic:r,wcDeepLink:_})}E()}),u()]).then(E=>E[2])},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:t,response:i}=e,{id:r}=i,a=this.client.session.get(t);a.transportType===g.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const l=this.getAppLinkIfEnabled(a.peer.metadata,a.transportType);D(i)?await this.sendResult({id:r,topic:t,result:i.result,throwOnFailedPublish:!0,appLink:l}):k(i)&&await this.sendError({id:r,topic:t,error:i.error,appLink:l}),this.cleanupAfterResponse(e)},this.ping=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(e)}catch(i){throw this.client.logger.error("ping() -> isValidPing() failed"),i}const{topic:t}=e;if(this.client.session.keys.includes(t)){const i=U(),r=he().toString(),{done:a,resolve:l,reject:c}=o.createDelayedPromise();this.events.once(o.engineEvent("session_ping",i),({error:h})=>{h?c(h):l()}),await Promise.all([this.sendRequest({topic:t,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:i,relayRpcId:r}),a()])}else this.client.core.pairing.pairings.keys.includes(t)&&await this.client.core.pairing.ping({topic:t})},this.emit=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(e);const{topic:t,event:i,chainId:r}=e,a=he().toString(),l=U();await this.sendRequest({topic:t,method:"wc_sessionEvent",params:{event:i,chainId:r},throwOnFailedPublish:!0,relayRpcId:a,clientRpcId:l})},this.disconnect=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(e);const{topic:t}=e;if(this.client.session.keys.includes(t))await this.sendRequest({topic:t,method:"wc_sessionDelete",params:o.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:t,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(t))await this.client.core.pairing.disconnect({topic:t});else{const{message:i}=o.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${t}`);throw new Error(i)}},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(t=>o.isSessionCompatible(t,e))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async(e,t)=>{var i;this.isInitialized(),this.isValidAuthenticate(e);const r=t&&this.client.core.linkModeSupportedApps.includes(t)&&((i=this.client.metadata.redirect)==null?void 0:i.linkMode),a=r?g.TRANSPORT_TYPES.link_mode:g.TRANSPORT_TYPES.relay;a===g.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const{chains:l,statement:c="",uri:h,domain:u,nonce:d,type:y,exp:p,nbf:E,methods:w=[],expiry:_}=e,S=[...e.resources||[]],{topic:R,uri:A}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:a});this.client.logger.info({message:"Generated new pairing",pairing:{topic:R,uri:A}});const m=await this.client.core.crypto.generateKeyPair(),T=o.hashKey(m);if(await Promise.all([this.client.auth.authKeys.set(B,{responseTopic:T,publicKey:m}),this.client.auth.pairingTopics.set(T,{topic:T,pairingTopic:R})]),await this.client.core.relayer.subscribe(T,{transportType:a}),this.client.logger.info(`sending request to new pairing topic: ${R}`),w.length>0){const{namespace:b}=o.parseChainId(l[0]);let O=o.createEncodedRecap(b,"request",w);o.getRecapFromResources(S)&&(O=o.mergeEncodedRecaps(O,S.pop())),S.push(O)}const x=_&&_>N.wc_sessionAuthenticate.req.ttl?_:N.wc_sessionAuthenticate.req.ttl,W={authPayload:{type:y??"caip122",chains:l,statement:c,aud:h,domain:u,version:"1",nonce:d,iat:new Date().toISOString(),exp:p,nbf:E,resources:S},requester:{publicKey:m,metadata:this.client.metadata},expiryTimestamp:o.calcExpiry(x)},P={eip155:{chains:l,methods:[...new Set(["personal_sign",...w])],events:["chainChanged","accountsChanged"]}},mt={requiredNamespaces:{},optionalNamespaces:P,relays:[{protocol:"irn"}],pairingTopic:R,proposer:{publicKey:m,metadata:this.client.metadata},expiryTimestamp:o.calcExpiry(N.wc_sessionPropose.req.ttl)},{done:Yi,resolve:_t,reject:Te}=o.createDelayedPromise(x,"Request expired"),ue=async({error:b,session:O})=>{if(this.events.off(o.engineEvent("session_request",$),Ie),b)Te(b);else if(O){O.self.publicKey=m,await this.client.session.set(O.topic,O),await this.setExpiry(O.topic,O.expiry),R&&await this.client.core.pairing.updateMetadata({topic:R,metadata:O.peer.metadata});const ge=this.client.session.get(O.topic);await this.deleteProposal(Z),_t({session:ge})}},Ie=async b=>{var O,ge,wt;if(await this.deletePendingAuthRequest($,{message:"fulfilled",code:0}),b.error){const te=o.getSdkError("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return b.error.code===te.code?void 0:(this.events.off(o.engineEvent("session_connect"),ue),Te(b.error.message))}await this.deleteProposal(Z),this.events.off(o.engineEvent("session_connect"),ue);const{cacaos:St,responder:K}=b.result,Oe=[],vt=[];for(const te of St){await o.validateSignedCacao({cacao:te,projectId:this.client.core.projectId})||(this.client.logger.error(te,"Signature verification failed"),Te(o.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:Pe}=te,qe=o.getRecapFromResources(Pe.resources),Rt=[o.getNamespacedDidChainId(Pe.iss)],Qi=o.getDidAddress(Pe.iss);if(qe){const be=o.getMethodsFromRecap(qe),Xi=o.getChainsFromRecap(qe);Oe.push(...be),Rt.push(...Xi)}for(const be of Rt)vt.push(`${be}:${Qi}`)}const ee=await this.client.core.crypto.generateSharedKey(m,K.publicKey);let Ee;Oe.length>0&&(Ee={topic:ee,acknowledged:!0,self:{publicKey:m,metadata:this.client.metadata},peer:K,controller:K.publicKey,expiry:o.calcExpiry(j),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:R,namespaces:o.buildNamespacesFromAuth([...new Set(Oe)],[...new Set(vt)]),transportType:a},await this.client.core.relayer.subscribe(ee,{transportType:a}),await this.client.session.set(ee,Ee),R&&await this.client.core.pairing.updateMetadata({topic:R,metadata:K.metadata}),Ee=this.client.session.get(ee)),(O=this.client.metadata.redirect)!=null&&O.linkMode&&(ge=K.metadata.redirect)!=null&&ge.linkMode&&(wt=K.metadata.redirect)!=null&&wt.universal&&t&&(this.client.core.addLinkModeSupportedApp(K.metadata.redirect.universal),this.client.session.update(ee,{transportType:g.TRANSPORT_TYPES.link_mode})),_t({auths:St,session:Ee})},$=U(),Z=U();this.events.once(o.engineEvent("session_connect"),ue),this.events.once(o.engineEvent("session_request",$),Ie);let Ne;try{if(r){const b=pe("wc_sessionAuthenticate",W,$);this.client.core.history.set(R,b);const O=await this.client.core.crypto.encode("",b,{type:o.TYPE_2,encoding:o.BASE64URL});Ne=o.getLinkModeURL(t,R,O)}else await Promise.all([this.sendRequest({topic:R,method:"wc_sessionAuthenticate",params:W,expiry:e.expiry,throwOnFailedPublish:!0,clientRpcId:$}),this.sendRequest({topic:R,method:"wc_sessionPropose",params:mt,expiry:N.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:Z})])}catch(b){throw this.events.off(o.engineEvent("session_connect"),ue),this.events.off(o.engineEvent("session_request",$),Ie),b}return await this.setProposal(Z,I({id:Z},mt)),await this.setAuthRequest($,{request:C(I({},W),{verifyContext:{}}),pairingTopic:R,transportType:a}),{uri:Ne??A,response:Yi}},this.approveSessionAuthenticate=async e=>{const{id:t,auths:i}=e,r=this.client.core.eventClient.createEvent({properties:{topic:t.toString(),trace:[g.EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started]}});try{this.isInitialized()}catch(_){throw r.setError(g.EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection),_}const a=this.getPendingAuthRequest(t);if(!a)throw r.setError(g.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${t}`);const l=a.transportType||g.TRANSPORT_TYPES.relay;l===g.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=a.requester.publicKey,h=await this.client.core.crypto.generateKeyPair(),u=o.hashKey(c),d={type:o.TYPE_1,receiverPublicKey:c,senderPublicKey:h},y=[],p=[];for(const _ of i){if(!await o.validateSignedCacao({cacao:_,projectId:this.client.core.projectId})){r.setError(g.EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);const T=o.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:t,topic:u,error:T,encodeOpts:d}),new Error(T.message)}r.addTrace(g.EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);const{p:S}=_,R=o.getRecapFromResources(S.resources),A=[o.getNamespacedDidChainId(S.iss)],m=o.getDidAddress(S.iss);if(R){const T=o.getMethodsFromRecap(R),x=o.getChainsFromRecap(R);y.push(...T),A.push(...x)}for(const T of A)p.push(`${T}:${m}`)}const E=await this.client.core.crypto.generateSharedKey(h,c);r.addTrace(g.EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);let w;if(y?.length>0){w={topic:E,acknowledged:!0,self:{publicKey:h,metadata:this.client.metadata},peer:{publicKey:c,metadata:a.requester.metadata},controller:c,expiry:o.calcExpiry(j),authentication:i,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:a.pairingTopic,namespaces:o.buildNamespacesFromAuth([...new Set(y)],[...new Set(p)]),transportType:l},r.addTrace(g.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(E,{transportType:l})}catch(_){throw r.setError(g.EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure),_}r.addTrace(g.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success),await this.client.session.set(E,w),r.addTrace(g.EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:a.pairingTopic,metadata:a.requester.metadata})}r.addTrace(g.EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);try{await this.sendResult({topic:u,id:t,result:{cacaos:i,responder:{publicKey:h,metadata:this.client.metadata}},encodeOpts:d,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(a.requester.metadata,l)})}catch(_){throw r.setError(g.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure),_}return await this.client.auth.requests.delete(t,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:a.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:r.eventId}),{session:w}},this.rejectSessionAuthenticate=async e=>{this.isInitialized();const{id:t,reason:i}=e,r=this.getPendingAuthRequest(t);if(!r)throw new Error(`Could not find pending auth request with id ${t}`);r.transportType===g.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const a=r.requester.publicKey,l=await this.client.core.crypto.generateKeyPair(),c=o.hashKey(a),h={type:o.TYPE_1,receiverPublicKey:a,senderPublicKey:l};await this.sendError({id:t,topic:c,error:i,encodeOpts:h,rpcOpts:N.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(r.requester.metadata,r.transportType)}),await this.client.auth.requests.delete(t,{message:"rejected",code:0}),await this.client.proposal.delete(t,o.getSdkError("USER_DISCONNECTED"))},this.formatAuthMessage=e=>{this.isInitialized();const{request:t,iss:i}=e;return o.formatMessage(t,i)},this.processRelayMessageCache=()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const e=this.relayMessageCache.shift();e&&await this.onRelayMessage(e)}catch(e){this.client.logger.error(e)}},50)},this.cleanupDuplicatePairings=async e=>{if(e.pairingTopic)try{const t=this.client.core.pairing.pairings.get(e.pairingTopic),i=this.client.core.pairing.pairings.getAll().filter(r=>{var a,l;return((a=r.peerMetadata)==null?void 0:a.url)&&((l=r.peerMetadata)==null?void 0:l.url)===e.peer.metadata.url&&r.topic&&r.topic!==t.topic});if(i.length===0)return;this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`),await Promise.all(i.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(t){this.client.logger.error(t)}},this.deleteSession=async e=>{var t;const{topic:i,expirerHasDeleted:r=!1,emitEvent:a=!0,id:l=0}=e,{self:c}=this.client.session.get(i);await this.client.core.relayer.unsubscribe(i),await this.client.session.delete(i,o.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(i,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(i)&&await this.client.core.crypto.deleteSymKey(i),r||this.client.core.expirer.del(i),this.client.core.storage.removeItem(ve).catch(h=>this.client.logger.warn(h)),this.getPendingSessionRequests().forEach(h=>{h.topic===i&&this.deletePendingSessionRequest(h.id,o.getSdkError("USER_DISCONNECTED"))}),i===((t=this.sessionRequestQueue.queue[0])==null?void 0:t.topic)&&(this.sessionRequestQueue.state=L.idle),a&&this.client.events.emit("session_delete",{id:l,topic:i})},this.deleteProposal=async(e,t)=>{if(t)try{const i=this.client.proposal.get(e),r=this.client.core.eventClient.getEvent({topic:i.pairingTopic});r?.setError(g.EVENT_CLIENT_SESSION_ERRORS.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(e,o.getSdkError("USER_DISCONNECTED")),t?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"proposal")},this.deletePendingSessionRequest=async(e,t,i=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,t),i?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==e),i&&(this.sessionRequestQueue.state=L.idle,this.client.events.emit("session_request_expire",{id:e}))},this.deletePendingAuthRequest=async(e,t,i=!1)=>{await Promise.all([this.client.auth.requests.delete(e,t),i?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,t)=>{this.client.session.keys.includes(e)&&(this.client.core.expirer.set(e,t),await this.client.session.update(e,{expiry:t}))},this.setProposal=async(e,t)=>{this.client.core.expirer.set(e,o.calcExpiry(N.wc_sessionPropose.req.ttl)),await this.client.proposal.set(e,t)},this.setAuthRequest=async(e,t)=>{const{request:i,pairingTopic:r,transportType:a=g.TRANSPORT_TYPES.relay}=t;this.client.core.expirer.set(e,i.expiryTimestamp),await this.client.auth.requests.set(e,{authPayload:i.authPayload,requester:i.requester,expiryTimestamp:i.expiryTimestamp,id:e,pairingTopic:r,verifyContext:i.verifyContext,transportType:a})},this.setPendingSessionRequest=async e=>{const{id:t,topic:i,params:r,verifyContext:a}=e,l=r.request.expiryTimestamp||o.calcExpiry(N.wc_sessionRequest.req.ttl);this.client.core.expirer.set(t,l),await this.client.pendingRequest.set(t,{id:t,topic:i,params:r,verifyContext:a})},this.sendRequest=async e=>{const{topic:t,method:i,params:r,expiry:a,relayRpcId:l,clientRpcId:c,throwOnFailedPublish:h,appLink:u}=e,d=pe(i,r,c);let y;const p=!!u;try{const _=p?o.BASE64URL:o.BASE64;y=await this.client.core.crypto.encode(t,d,{encoding:_})}catch(_){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`),_}let E;if(it.includes(i)){const _=o.hashMessage(JSON.stringify(d)),S=o.hashMessage(y);E=await this.client.core.verify.register({id:S,decryptedId:_})}const w=N[i].req;if(w.attestation=E,a&&(w.ttl=a),l&&(w.id=l),this.client.core.history.set(t,d),p){const _=o.getLinkModeURL(u,t,y);await global.Linking.openURL(_,this.client.name)}else{const _=N[i].req;a&&(_.ttl=a),l&&(_.id=l),h?(_.internal=C(I({},_.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,y,_)):this.client.core.relayer.publish(t,y,_).catch(S=>this.client.logger.error(S))}return d.id},this.sendResult=async e=>{const{id:t,topic:i,result:r,throwOnFailedPublish:a,encodeOpts:l,appLink:c}=e,h=Pi(t,r);let u;const d=c&&typeof(global==null?void 0:global.Linking)<"u";try{const p=d?o.BASE64URL:o.BASE64;u=await this.client.core.crypto.encode(i,h,C(I({},l||{}),{encoding:p}))}catch(p){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`),p}let y;try{y=await this.client.core.history.get(i,t)}catch(p){throw this.client.logger.error(`sendResult() -> history.get(${i}, ${t}) failed`),p}if(d){const p=o.getLinkModeURL(c,i,u);await global.Linking.openURL(p,this.client.name)}else{const p=N[y.request.method].res;a?(p.internal=C(I({},p.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(i,u,p)):this.client.core.relayer.publish(i,u,p).catch(E=>this.client.logger.error(E))}await this.client.core.history.resolve(h)},this.sendError=async e=>{const{id:t,topic:i,error:r,encodeOpts:a,rpcOpts:l,appLink:c}=e,h=qi(t,r);let u;const d=c&&typeof(global==null?void 0:global.Linking)<"u";try{const p=d?o.BASE64URL:o.BASE64;u=await this.client.core.crypto.encode(i,h,C(I({},a||{}),{encoding:p}))}catch(p){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`),p}let y;try{y=await this.client.core.history.get(i,t)}catch(p){throw this.client.logger.error(`sendError() -> history.get(${i}, ${t}) failed`),p}if(d){const p=o.getLinkModeURL(c,i,u);await global.Linking.openURL(p,this.client.name)}else{const p=l||N[y.request.method].res;this.client.core.relayer.publish(i,u,p)}await this.client.core.history.resolve(h)},this.cleanup=async()=>{const e=[],t=[];this.client.session.getAll().forEach(i=>{let r=!1;o.isExpired(i.expiry)&&(r=!0),this.client.core.crypto.keychain.has(i.topic)||(r=!0),r&&e.push(i.topic)}),this.client.proposal.getAll().forEach(i=>{o.isExpired(i.expiryTimestamp)&&t.push(i.id)}),await Promise.all([...e.map(i=>this.deleteSession({topic:i})),...t.map(i=>this.deleteProposal(i))])},this.onRelayEventRequest=async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===L.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=L.active;const e=this.requestQueue.queue.shift();if(e)try{await this.processRequest(e)}catch(t){this.client.logger.warn(t)}}this.requestQueue.state=L.idle},this.processRequest=async e=>{const{topic:t,payload:i,attestation:r,transportType:a,encryptedId:l}=e,c=i.method;if(!this.shouldIgnorePairingRequest({topic:t,requestMethod:c}))switch(c){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:t,payload:i,attestation:r,encryptedId:l});case"wc_sessionSettle":return await this.onSessionSettleRequest(t,i);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(t,i);case"wc_sessionExtend":return await this.onSessionExtendRequest(t,i);case"wc_sessionPing":return await this.onSessionPingRequest(t,i);case"wc_sessionDelete":return await this.onSessionDeleteRequest(t,i);case"wc_sessionRequest":return await this.onSessionRequest({topic:t,payload:i,attestation:r,encryptedId:l,transportType:a});case"wc_sessionEvent":return await this.onSessionEventRequest(t,i);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:t,payload:i,attestation:r,encryptedId:l,transportType:a});default:return this.client.logger.info(`Unsupported request method ${c}`)}},this.onRelayEventResponse=async e=>{const{topic:t,payload:i,transportType:r}=e,a=(await this.client.core.history.get(t,i.id)).request.method;switch(a){case"wc_sessionPropose":return this.onSessionProposeResponse(t,i,r);case"wc_sessionSettle":return this.onSessionSettleResponse(t,i);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,i);case"wc_sessionExtend":return this.onSessionExtendResponse(t,i);case"wc_sessionPing":return this.onSessionPingResponse(t,i);case"wc_sessionRequest":return this.onSessionRequestResponse(t,i);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(t,i);default:return this.client.logger.info(`Unsupported response method ${a}`)}},this.onRelayEventUnknownPayload=e=>{const{topic:t}=e,{message:i}=o.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);throw new Error(i)},this.shouldIgnorePairingRequest=e=>{const{topic:t,requestMethod:i}=e,r=this.expectedPairingMethodMap.get(t);return!r||r.includes(i)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async e=>{const{topic:t,payload:i,attestation:r,encryptedId:a}=e,{params:l,id:c}=i;try{const h=this.client.core.eventClient.getEvent({topic:t});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),h?.setError(g.EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found)),this.isValidConnect(I({},i.params));const u=l.expiryTimestamp||o.calcExpiry(N.wc_sessionPropose.req.ttl),d=I({id:c,pairingTopic:t,expiryTimestamp:u},l);await this.setProposal(c,d);const y=await this.getVerifyContext({attestationId:r,hash:o.hashMessage(JSON.stringify(i)),encryptedId:a,metadata:d.proposer.metadata});h?.addTrace(g.EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:d,verifyContext:y})}catch(h){await this.sendError({id:c,topic:t,error:h,rpcOpts:N.wc_sessionPropose.autoReject}),this.client.logger.error(h)}},this.onSessionProposeResponse=async(e,t,i)=>{const{id:r}=t;if(D(t)){const{result:a}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:a});const l=this.client.proposal.get(r);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:l});const c=l.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const h=a.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:h});const u=await this.client.core.crypto.generateSharedKey(c,h);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:u});const d=await this.client.core.relayer.subscribe(u,{transportType:i});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:d}),await this.client.core.pairing.activate({topic:e})}else if(k(t)){await this.client.proposal.delete(r,o.getSdkError("USER_DISCONNECTED"));const a=o.engineEvent("session_connect");if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners, 954`);this.events.emit(o.engineEvent("session_connect"),{error:t.error})}},this.onSessionSettleRequest=async(e,t)=>{const{id:i,params:r}=t;try{this.isValidSessionSettleRequest(r);const{relay:a,controller:l,expiry:c,namespaces:h,sessionProperties:u,sessionConfig:d}=t.params,y=C(I(I({topic:e,relay:a,expiry:c,namespaces:h,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:l.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:l.publicKey,metadata:l.metadata}},u&&{sessionProperties:u}),d&&{sessionConfig:d}),{transportType:g.TRANSPORT_TYPES.relay}),p=o.engineEvent("session_connect");if(this.events.listenerCount(p)===0)throw new Error(`emitting ${p} without any listeners 997`);this.events.emit(o.engineEvent("session_connect"),{session:y}),await this.sendResult({id:t.id,topic:e,result:!0,throwOnFailedPublish:!0})}catch(a){await this.sendError({id:i,topic:e,error:a}),this.client.logger.error(a)}},this.onSessionSettleResponse=async(e,t)=>{const{id:i}=t;D(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(o.engineEvent("session_approve",i),{})):k(t)&&(await this.client.session.delete(e,o.getSdkError("USER_DISCONNECTED")),this.events.emit(o.engineEvent("session_approve",i),{error:t.error}))},this.onSessionUpdateRequest=async(e,t)=>{const{params:i,id:r}=t;try{const a=`${e}_session_update`,l=o.MemoryStore.get(a);if(l&&this.isRequestOutOfSync(l,r)){this.client.logger.warn(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:e,error:o.getSdkError("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(I({topic:e},i));try{o.MemoryStore.set(a,r),await this.client.session.update(e,{namespaces:i.namespaces}),await this.sendResult({id:r,topic:e,result:!0,throwOnFailedPublish:!0})}catch(c){throw o.MemoryStore.delete(a),c}this.client.events.emit("session_update",{id:r,topic:e,params:i})}catch(a){await this.sendError({id:r,topic:e,error:a}),this.client.logger.error(a)}},this.isRequestOutOfSync=(e,t)=>t.toString().slice(0,-3)<e.toString().slice(0,-3),this.onSessionUpdateResponse=(e,t)=>{const{id:i}=t,r=o.engineEvent("session_update",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);D(t)?this.events.emit(o.engineEvent("session_update",i),{}):k(t)&&this.events.emit(o.engineEvent("session_update",i),{error:t.error})},this.onSessionExtendRequest=async(e,t)=>{const{id:i}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,o.calcExpiry(j)),await this.sendResult({id:i,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:i,topic:e})}catch(r){await this.sendError({id:i,topic:e,error:r}),this.client.logger.error(r)}},this.onSessionExtendResponse=(e,t)=>{const{id:i}=t,r=o.engineEvent("session_extend",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);D(t)?this.events.emit(o.engineEvent("session_extend",i),{}):k(t)&&this.events.emit(o.engineEvent("session_extend",i),{error:t.error})},this.onSessionPingRequest=async(e,t)=>{const{id:i}=t;try{this.isValidPing({topic:e}),await this.sendResult({id:i,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:i,topic:e})}catch(r){await this.sendError({id:i,topic:e,error:r}),this.client.logger.error(r)}},this.onSessionPingResponse=(e,t)=>{const{id:i}=t,r=o.engineEvent("session_ping",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);setTimeout(()=>{D(t)?this.events.emit(o.engineEvent("session_ping",i),{}):k(t)&&this.events.emit(o.engineEvent("session_ping",i),{error:t.error})},500)},this.onSessionDeleteRequest=async(e,t)=>{const{id:i}=t;try{this.isValidDisconnect({topic:e,reason:t.params}),Promise.all([new Promise(r=>{this.client.core.relayer.once(g.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession({topic:e,id:i}))})}),this.sendResult({id:i,topic:e,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:e,error:o.getSdkError("USER_DISCONNECTED")})]).catch(r=>this.client.logger.error(r))}catch(r){this.client.logger.error(r)}},this.onSessionRequest=async e=>{var t,i,r;const{topic:a,payload:l,attestation:c,encryptedId:h,transportType:u}=e,{id:d,params:y}=l;try{await this.isValidRequest(I({topic:a},y));const p=this.client.session.get(a),E=await this.getVerifyContext({attestationId:c,hash:o.hashMessage(JSON.stringify(pe("wc_sessionRequest",y,d))),encryptedId:h,metadata:p.peer.metadata,transportType:u}),w={id:d,topic:a,params:y,verifyContext:E};await this.setPendingSessionRequest(w),u===g.TRANSPORT_TYPES.link_mode&&(t=p.peer.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp((i=p.peer.metadata.redirect)==null?void 0:i.universal),(r=this.client.signConfig)!=null&&r.disableRequestQueue?this.emitSessionRequest(w):(this.addSessionRequestToSessionRequestQueue(w),this.processSessionRequestQueue())}catch(p){await this.sendError({id:d,topic:a,error:p}),this.client.logger.error(p)}},this.onSessionRequestResponse=(e,t)=>{const{id:i}=t,r=o.engineEvent("session_request",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);D(t)?this.events.emit(o.engineEvent("session_request",i),{result:t.result}):k(t)&&this.events.emit(o.engineEvent("session_request",i),{error:t.error})},this.onSessionEventRequest=async(e,t)=>{const{id:i,params:r}=t;try{const a=`${e}_session_event_${r.event.name}`,l=o.MemoryStore.get(a);if(l&&this.isRequestOutOfSync(l,i)){this.client.logger.info(`Discarding out of sync request - ${i}`);return}this.isValidEmit(I({topic:e},r)),this.client.events.emit("session_event",{id:i,topic:e,params:r}),o.MemoryStore.set(a,i)}catch(a){await this.sendError({id:i,topic:e,error:a}),this.client.logger.error(a)}},this.onSessionAuthenticateResponse=(e,t)=>{const{id:i}=t;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:e,payload:t}),D(t)?this.events.emit(o.engineEvent("session_request",i),{result:t.result}):k(t)&&this.events.emit(o.engineEvent("session_request",i),{error:t.error})},this.onSessionAuthenticateRequest=async e=>{var t;const{topic:i,payload:r,attestation:a,encryptedId:l,transportType:c}=e;try{const{requester:h,authPayload:u,expiryTimestamp:d}=r.params,y=await this.getVerifyContext({attestationId:a,hash:o.hashMessage(JSON.stringify(r)),encryptedId:l,metadata:h.metadata,transportType:c}),p={requester:h,pairingTopic:i,id:r.id,authPayload:u,verifyContext:y,expiryTimestamp:d};await this.setAuthRequest(r.id,{request:p,pairingTopic:i,transportType:c}),c===g.TRANSPORT_TYPES.link_mode&&(t=h.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp(h.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:i,params:r.params,id:r.id,verifyContext:y})}catch(h){this.client.logger.error(h);const u=r.params.requester.publicKey,d=await this.client.core.crypto.generateKeyPair(),y=this.getAppLinkIfEnabled(r.params.requester.metadata,c),p={type:o.TYPE_1,receiverPublicKey:u,senderPublicKey:d};await this.sendError({id:r.id,topic:i,error:h,encodeOpts:p,rpcOpts:N.wc_sessionAuthenticate.autoReject,appLink:y})}},this.addSessionRequestToSessionRequestQueue=e=>{this.sessionRequestQueue.queue.push(e)},this.cleanupAfterResponse=e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=L.idle,this.processSessionRequestQueue()},me(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:e,error:t})=>{const i=this.client.core.history.pending;i.length>0&&i.filter(r=>r.topic===e&&r.request.method==="wc_sessionRequest").forEach(r=>{const a=r.request.id,l=o.engineEvent("session_request",a);if(this.events.listenerCount(l)===0)throw new Error(`emitting ${l} without any listeners`);this.events.emit(o.engineEvent("session_request",r.request.id),{error:t})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===L.active){this.client.logger.info("session request queue is already active.");return}const e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=L.active,this.emitSessionRequest(e)}catch(t){this.client.logger.error(t)}},this.emitSessionRequest=e=>{this.client.events.emit("session_request",e)},this.onPairingCreated=e=>{if(e.methods&&this.expectedPairingMethodMap.set(e.topic,e.methods),e.active)return;const t=this.client.proposal.getAll().find(i=>i.pairingTopic===e.topic);t&&this.onSessionProposeRequest({topic:e.topic,payload:pe("wc_sessionPropose",{requiredNamespaces:t.requiredNamespaces,optionalNamespaces:t.optionalNamespaces,relays:t.relays,proposer:t.proposer,sessionProperties:t.sessionProperties},t.id)})},this.isValidConnect=async e=>{if(!o.isValidParams(e)){const{message:c}=o.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(c)}const{pairingTopic:t,requiredNamespaces:i,optionalNamespaces:r,sessionProperties:a,relays:l}=e;if(o.isUndefined(t)||await this.isValidPairingTopic(t),!o.isValidRelays(l,!0)){const{message:c}=o.getInternalError("MISSING_OR_INVALID",`connect() relays: ${l}`);throw new Error(c)}!o.isUndefined(i)&&o.isValidObject(i)!==0&&this.validateNamespaces(i,"requiredNamespaces"),!o.isUndefined(r)&&o.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),o.isUndefined(a)||this.validateSessionProps(a,"sessionProperties")},this.validateNamespaces=(e,t)=>{const i=o.isValidRequiredNamespaces(e,"connect()",t);if(i)throw new Error(i.message)},this.isValidApprove=async e=>{if(!o.isValidParams(e))throw new Error(o.getInternalError("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:t,namespaces:i,relayProtocol:r,sessionProperties:a}=e;this.checkRecentlyDeleted(t),await this.isValidProposalId(t);const l=this.client.proposal.get(t),c=o.isValidNamespaces(i,"approve()");if(c)throw new Error(c.message);const h=o.isConformingNamespaces(l.requiredNamespaces,i,"approve()");if(h)throw new Error(h.message);if(!o.isValidString(r,!0)){const{message:u}=o.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(u)}o.isUndefined(a)||this.validateSessionProps(a,"sessionProperties")},this.isValidReject=async e=>{if(!o.isValidParams(e)){const{message:r}=o.getInternalError("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(r)}const{id:t,reason:i}=e;if(this.checkRecentlyDeleted(t),await this.isValidProposalId(t),!o.isValidErrorReason(i)){const{message:r}=o.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(i)}`);throw new Error(r)}},this.isValidSessionSettleRequest=e=>{if(!o.isValidParams(e)){const{message:h}=o.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(h)}const{relay:t,controller:i,namespaces:r,expiry:a}=e;if(!o.isValidRelay(t)){const{message:h}=o.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(h)}const l=o.isValidController(i,"onSessionSettleRequest()");if(l)throw new Error(l.message);const c=o.isValidNamespaces(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(o.isExpired(a)){const{message:h}=o.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(h)}},this.isValidUpdate=async e=>{if(!o.isValidParams(e)){const{message:c}=o.getInternalError("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(c)}const{topic:t,namespaces:i}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const r=this.client.session.get(t),a=o.isValidNamespaces(i,"update()");if(a)throw new Error(a.message);const l=o.isConformingNamespaces(r.requiredNamespaces,i,"update()");if(l)throw new Error(l.message)},this.isValidExtend=async e=>{if(!o.isValidParams(e)){const{message:i}=o.getInternalError("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(i)}const{topic:t}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t)},this.isValidRequest=async e=>{if(!o.isValidParams(e)){const{message:c}=o.getInternalError("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(c)}const{topic:t,request:i,chainId:r,expiry:a}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const{namespaces:l}=this.client.session.get(t);if(!o.isValidNamespacesChainId(l,r)){const{message:c}=o.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!o.isValidRequest(i)){const{message:c}=o.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(i)}`);throw new Error(c)}if(!o.isValidNamespacesRequest(l,r,i.method)){const{message:c}=o.getInternalError("MISSING_OR_INVALID",`request() method: ${i.method}`);throw new Error(c)}if(a&&!o.isValidRequestExpiry(a,le)){const{message:c}=o.getInternalError("MISSING_OR_INVALID",`request() expiry: ${a}. Expiry must be a number (in seconds) between ${le.min} and ${le.max}`);throw new Error(c)}},this.isValidRespond=async e=>{var t;if(!o.isValidParams(e)){const{message:a}=o.getInternalError("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(a)}const{topic:i,response:r}=e;try{await this.isValidSessionTopic(i)}catch(a){throw(t=e?.response)!=null&&t.id&&this.cleanupAfterResponse(e),a}if(!o.isValidResponse(r)){const{message:a}=o.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(a)}},this.isValidPing=async e=>{if(!o.isValidParams(e)){const{message:i}=o.getInternalError("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(i)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)},this.isValidEmit=async e=>{if(!o.isValidParams(e)){const{message:l}=o.getInternalError("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(l)}const{topic:t,event:i,chainId:r}=e;await this.isValidSessionTopic(t);const{namespaces:a}=this.client.session.get(t);if(!o.isValidNamespacesChainId(a,r)){const{message:l}=o.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(l)}if(!o.isValidEvent(i)){const{message:l}=o.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(l)}if(!o.isValidNamespacesEvent(a,r,i.name)){const{message:l}=o.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(l)}},this.isValidDisconnect=async e=>{if(!o.isValidParams(e)){const{message:i}=o.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(i)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)},this.isValidAuthenticate=e=>{const{chains:t,uri:i,domain:r,nonce:a}=e;if(!Array.isArray(t)||t.length===0)throw new Error("chains is required and must be a non-empty array");if(!o.isValidString(i,!1))throw new Error("uri is required parameter");if(!o.isValidString(r,!1))throw new Error("domain is required parameter");if(!o.isValidString(a,!1))throw new Error("nonce is required parameter");if([...new Set(t.map(c=>o.parseChainId(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:l}=o.parseChainId(t[0]);if(l!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async e=>{const{attestationId:t,hash:i,encryptedId:r,metadata:a,transportType:l}=e,c={verified:{verifyUrl:a.verifyUrl||g.VERIFY_SERVER,validation:"UNKNOWN",origin:a.url||""}};try{if(l===g.TRANSPORT_TYPES.link_mode){const u=this.getAppLinkIfEnabled(a,l);return c.verified.validation=u&&new URL(u).origin===new URL(a.url).origin?"VALID":"INVALID",c}const h=await this.client.core.verify.resolve({attestationId:t,hash:i,encryptedId:r,verifyUrl:a.verifyUrl});h&&(c.verified.origin=h.origin,c.verified.isScam=h.isScam,c.verified.validation=h.origin===new URL(a.url).origin?"VALID":"INVALID")}catch(h){this.client.logger.warn(h)}return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),c},this.validateSessionProps=(e,t)=>{Object.values(e).forEach(i=>{if(!o.isValidString(i,!1)){const{message:r}=o.getInternalError("MISSING_OR_INVALID",`${t} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);throw new Error(r)}})},this.getPendingAuthRequest=e=>{const t=this.client.auth.requests.get(e);return typeof t=="object"?t:void 0},this.addToRecentlyDeleted=(e,t)=>{if(this.recentlyDeletedMap.set(e,t),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let i=0;const r=this.recentlyDeletedLimit/2;for(const a of this.recentlyDeletedMap.keys()){if(i++>=r)break;this.recentlyDeletedMap.delete(a)}}},this.checkRecentlyDeleted=e=>{const t=this.recentlyDeletedMap.get(e);if(t){const{message:i}=o.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${t}: ${e}`);throw new Error(i)}},this.isLinkModeEnabled=(e,t)=>{var i,r,a,l,c,h,u,d,y;return!e||t!==g.TRANSPORT_TYPES.link_mode?!1:((r=(i=this.client.metadata)==null?void 0:i.redirect)==null?void 0:r.linkMode)===!0&&((l=(a=this.client.metadata)==null?void 0:a.redirect)==null?void 0:l.universal)!==void 0&&((h=(c=this.client.metadata)==null?void 0:c.redirect)==null?void 0:h.universal)!==""&&((u=e?.redirect)==null?void 0:u.universal)!==void 0&&((d=e?.redirect)==null?void 0:d.universal)!==""&&((y=e?.redirect)==null?void 0:y.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(e.redirect.universal)&&typeof(global==null?void 0:global.Linking)<"u"},this.getAppLinkIfEnabled=(e,t)=>{var i;return this.isLinkModeEnabled(e,t)?(i=e?.redirect)==null?void 0:i.universal:void 0},this.handleLinkModeMessage=({url:e})=>{if(!e||!e.includes("wc_ev")||!e.includes("topic"))return;const t=o.getSearchParamFromURL(e,"topic")||"",i=decodeURIComponent(o.getSearchParamFromURL(e,"wc_ev")||""),r=this.client.session.keys.includes(t);r&&this.client.session.update(t,{transportType:g.TRANSPORT_TYPES.link_mode}),this.client.core.dispatchEnvelope({topic:t,message:i,sessionExists:r})},this.registerLinkModeListeners=async()=>{var e;if(o.isTestRun()||o.isReactNative()&&(e=this.client.metadata.redirect)!=null&&e.linkMode){const t=global==null?void 0:global.Linking;if(typeof t<"u"){t.addEventListener("url",this.handleLinkModeMessage,this.client.name);const i=await t.getInitialURL();i&&setTimeout(()=>{this.handleLinkModeMessage({url:i})},50)}}}}isInitialized(){if(!this.initialized){const{message:s}=o.getInternalError("NOT_INITIALIZED",this.name);throw new Error(s)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(g.RELAYER_EVENTS.message,s=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(s):this.onRelayMessage(s)})}async onRelayMessage(s){const{topic:e,message:t,attestation:i,transportType:r}=s,{publicKey:a}=this.client.auth.authKeys.keys.includes(B)?this.client.auth.authKeys.get(B):{responseTopic:void 0,publicKey:void 0},l=await this.client.core.crypto.decode(e,t,{receiverPublicKey:a,encoding:r===g.TRANSPORT_TYPES.link_mode?o.BASE64URL:o.BASE64});try{Ai(l)?(this.client.core.history.set(e,l),this.onRelayEventRequest({topic:e,payload:l,attestation:i,transportType:r,encryptedId:o.hashMessage(t)})):Li(l)?(await this.client.core.history.resolve(l),await this.onRelayEventResponse({topic:e,payload:l,transportType:r}),this.client.core.history.delete(e,l.id)):this.onRelayEventUnknownPayload({topic:e,payload:l,transportType:r})}catch(c){this.client.logger.error(c)}}registerExpirerEvents(){this.client.core.expirer.on(g.EXPIRER_EVENTS.expired,async s=>{const{topic:e,id:t}=o.parseExpirerTarget(s.target);if(t&&this.client.pendingRequest.keys.includes(t))return await this.deletePendingSessionRequest(t,o.getInternalError("EXPIRED"),!0);if(t&&this.client.auth.requests.keys.includes(t))return await this.deletePendingAuthRequest(t,o.getInternalError("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession({topic:e,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:e})):t&&(await this.deleteProposal(t,!0),this.client.events.emit("proposal_expire",{id:t}))})}registerPairingEvents(){this.client.core.pairing.events.on(g.PAIRING_EVENTS.create,s=>this.onPairingCreated(s)),this.client.core.pairing.events.on(g.PAIRING_EVENTS.delete,s=>{this.addToRecentlyDeleted(s.topic,"pairing")})}isValidPairingTopic(s){if(!o.isValidString(s,!1)){const{message:e}=o.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${s}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(s)){const{message:e}=o.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${s}`);throw new Error(e)}if(o.isExpired(this.client.core.pairing.pairings.get(s).expiry)){const{message:e}=o.getInternalError("EXPIRED",`pairing topic: ${s}`);throw new Error(e)}}async isValidSessionTopic(s){if(!o.isValidString(s,!1)){const{message:e}=o.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${s}`);throw new Error(e)}if(this.checkRecentlyDeleted(s),!this.client.session.keys.includes(s)){const{message:e}=o.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${s}`);throw new Error(e)}if(o.isExpired(this.client.session.get(s).expiry)){await this.deleteSession({topic:s});const{message:e}=o.getInternalError("EXPIRED",`session topic: ${s}`);throw new Error(e)}if(!this.client.core.crypto.keychain.has(s)){const{message:e}=o.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${s}`);throw await this.deleteSession({topic:s}),new Error(e)}}async isValidSessionOrPairingTopic(s){if(this.checkRecentlyDeleted(s),this.client.session.keys.includes(s))await this.isValidSessionTopic(s);else if(this.client.core.pairing.pairings.keys.includes(s))this.isValidPairingTopic(s);else if(o.isValidString(s,!1)){const{message:e}=o.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${s}`);throw new Error(e)}else{const{message:e}=o.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${s}`);throw new Error(e)}}async isValidProposalId(s){if(!o.isValidId(s)){const{message:e}=o.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${s}`);throw new Error(e)}if(!this.client.proposal.keys.includes(s)){const{message:e}=o.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${s}`);throw new Error(e)}if(o.isExpired(this.client.proposal.get(s).expiryTimestamp)){await this.deleteProposal(s);const{message:e}=o.getInternalError("EXPIRED",`proposal id: ${s}`);throw new Error(e)}}}class Ui extends g.Store{constructor(s,e){super(s,e,Je,ae),this.core=s,this.logger=e}}class ft extends g.Store{constructor(s,e){super(s,e,Ze,ae),this.core=s,this.logger=e}}class ji extends g.Store{constructor(s,e){super(s,e,tt,ae,t=>t.id),this.core=s,this.logger=e}}class $i extends g.Store{constructor(s,e){super(s,e,rt,X,()=>B),this.core=s,this.logger=e}}class Ki extends g.Store{constructor(s,e){super(s,e,ot,X),this.core=s,this.logger=e}}class Gi extends g.Store{constructor(s,e){super(s,e,at,X,t=>t.id),this.core=s,this.logger=e}}class zi{constructor(s,e){this.core=s,this.logger=e,this.authKeys=new $i(this.core,this.logger),this.pairingTopics=new Ki(this.core,this.logger),this.requests=new Gi(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class de extends Ae.ISignClient{constructor(s){super(s),this.protocol=_e,this.version=we,this.name=ce.name,this.events=new ne.exports.EventEmitter,this.on=(t,i)=>this.events.on(t,i),this.once=(t,i)=>this.events.once(t,i),this.off=(t,i)=>this.events.off(t,i),this.removeListener=(t,i)=>this.events.removeListener(t,i),this.removeAllListeners=t=>this.events.removeAllListeners(t),this.connect=async t=>{try{return await this.engine.connect(t)}catch(i){throw this.logger.error(i.message),i}},this.pair=async t=>{try{return await this.engine.pair(t)}catch(i){throw this.logger.error(i.message),i}},this.approve=async t=>{try{return await this.engine.approve(t)}catch(i){throw this.logger.error(i.message),i}},this.reject=async t=>{try{return await this.engine.reject(t)}catch(i){throw this.logger.error(i.message),i}},this.update=async t=>{try{return await this.engine.update(t)}catch(i){throw this.logger.error(i.message),i}},this.extend=async t=>{try{return await this.engine.extend(t)}catch(i){throw this.logger.error(i.message),i}},this.request=async t=>{try{return await this.engine.request(t)}catch(i){throw this.logger.error(i.message),i}},this.respond=async t=>{try{return await this.engine.respond(t)}catch(i){throw this.logger.error(i.message),i}},this.ping=async t=>{try{return await this.engine.ping(t)}catch(i){throw this.logger.error(i.message),i}},this.emit=async t=>{try{return await this.engine.emit(t)}catch(i){throw this.logger.error(i.message),i}},this.disconnect=async t=>{try{return await this.engine.disconnect(t)}catch(i){throw this.logger.error(i.message),i}},this.find=t=>{try{return this.engine.find(t)}catch(i){throw this.logger.error(i.message),i}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(t){throw this.logger.error(t.message),t}},this.authenticate=async(t,i)=>{try{return await this.engine.authenticate(t,i)}catch(r){throw this.logger.error(r.message),r}},this.formatAuthMessage=t=>{try{return this.engine.formatAuthMessage(t)}catch(i){throw this.logger.error(i.message),i}},this.approveSessionAuthenticate=async t=>{try{return await this.engine.approveSessionAuthenticate(t)}catch(i){throw this.logger.error(i.message),i}},this.rejectSessionAuthenticate=async t=>{try{return await this.engine.rejectSessionAuthenticate(t)}catch(i){throw this.logger.error(i.message),i}},this.name=s?.name||ce.name,this.metadata=s?.metadata||o.getAppMetadata(),this.signConfig=s?.signConfig;const e=typeof s?.logger<"u"&&typeof s?.logger!="string"?s.logger:Ot(Ht({level:s?.logger||ce.logger}));this.core=s?.core||new g.Core(s),this.logger=Bt(e,this.name),this.session=new ft(this.core,this.logger),this.proposal=new Ui(this.core,this.logger),this.pendingRequest=new ji(this.core,this.logger),this.engine=new Mi(this),this.auth=new zi(this.core,this.logger)}static async init(s){const e=new de(s);return await e.initialize(),e}get context(){return ke(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},me(Me))}catch(s){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(s.message),s}}}const Fi=ft,Hi=de;f.AUTH_CONTEXT=nt,f.AUTH_KEYS_CONTEXT=rt,f.AUTH_PAIRING_TOPIC_CONTEXT=ot,f.AUTH_PROTOCOL=st,f.AUTH_PUBLIC_KEY_NAME=B,f.AUTH_REQUEST_CONTEXT=at,f.AUTH_STORAGE_PREFIX=X,f.AUTH_VERSION=pi,f.ENGINE_CONTEXT=et,f.ENGINE_QUEUE_STATES=L,f.ENGINE_RPC_OPTS=N,f.HISTORY_CONTEXT=ci,f.HISTORY_EVENTS=ai,f.HISTORY_STORAGE_VERSION=li,f.METHODS_TO_VERIFY=it,f.PROPOSAL_CONTEXT=Je,f.PROPOSAL_EXPIRY=hi,f.PROPOSAL_EXPIRY_MESSAGE=We,f.REQUEST_CONTEXT=tt,f.SESSION_CONTEXT=Ze,f.SESSION_EXPIRY=j,f.SESSION_REQUEST_EXPIRY_BOUNDARIES=le,f.SIGN_CLIENT_CONTEXT=Se,f.SIGN_CLIENT_DEFAULT=ce,f.SIGN_CLIENT_EVENTS=ri,f.SIGN_CLIENT_PROTOCOL=_e,f.SIGN_CLIENT_STORAGE_OPTIONS=oi,f.SIGN_CLIENT_STORAGE_PREFIX=ae,f.SIGN_CLIENT_VERSION=we,f.SessionStore=Fi,f.SignClient=Hi,f.WALLETCONNECT_DEEPLINK_CHOICE=ve,f.default=de,Object.defineProperty(f,"__esModule",{value:!0})});
//# sourceMappingURL=index.umd.js.map

"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var b=require("@noble/ed25519"),I=require("@cosmoskitconnect/cacao"),P=require("@cosmoskitconnect/core"),y=require("@cosmoskitconnect/did-jwt"),d=require("@cosmoskitconnect/utils"),m=require("axios");function E(a){return a&&typeof a=="object"&&"default"in a?a:{default:a}}function k(a){if(a&&a.__esModule)return a;var e=Object.create(null);return a&&Object.keys(a).forEach(function(t){if(t!=="default"){var r=Object.getOwnPropertyDescriptor(a,t);Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:function(){return a[t]}})}}),e.default=a,Object.freeze(e)}var l=k(b),g=E(m);const v="https://keys.walletconnect.com",_="wc@2:identityKeys:";class ${constructor(e,t,r){this.core=e,this.projectId=t,this.init=async()=>{await this.identityKeys.init()},this.generateIdAuth=async(i,s)=>{const{identityKeyPub:n,identityKeyPriv:o}=this.identityKeys.get(i);return y.generateJWT([n,o],s)},this.generateIdentityKey=()=>{const i=l.utils.randomPrivateKey();return this.getKeyData(i)},this.getKeyHex=i=>l.utils.bytesToHex(i).toLowerCase(),this.getKeyData=async i=>{const s=await l.getPublicKey(i);return{publicKey:s,privateKey:i,pubKeyHex:this.getKeyHex(s),privKeyHex:this.getKeyHex(i)}},this.keyserverUrl=r??v,this.identityKeys=new P.Store(e,this.core.logger,"identityKeys",_,i=>i.accountId)}isRegistered(e){return this.identityKeys.keys.includes(e)}async prepareRegistrationWithRecaps({domain:e,recapObject:t}){const r=`urn:recap:${y.objectToHex(t)}`,{pubKeyHex:i,privateKey:s}=await this.generateIdentityKey(),n=y.encodeEd25519Key(i),o=`https://${e}?walletconnect_identity_key=${n}`;return{cacaoPayload:{aud:o,uri:o,statement:void 0,domain:e,nonce:d.generateRandomBytes32(),iat:new Date().toISOString(),version:"1",resources:[this.keyserverUrl,r]},privateIdentityKey:s}}async prepareRegistration({domain:e,accountId:t,statement:r}){const{privateKey:i,pubKeyHex:s}=await this.generateIdentityKey(),n={aud:y.encodeEd25519Key(s),statement:r,domain:e,iss:y.composeDidPkh(t),nonce:d.generateRandomBytes32(),iat:new Date().toISOString(),version:"1",resources:[this.keyserverUrl]};return{message:d.formatMessage(n,y.composeDidPkh(t)),registerParams:{cacaoPayload:n,privateIdentityKey:i}}}async registerIdentity({registerParams:e,signature:t}){const r=e.cacaoPayload.iss.split(":").slice(-3).join(":");if(this.isRegistered(r))return this.identityKeys.get(r).identityKeyPub;try{const i=d.formatMessage(e.cacaoPayload,e.cacaoPayload.iss);if(!t.s)throw new Error(`Provided an invalid signature. Expected a string but got: ${t.s}`);const[s,n,o]=r.split(":"),c=`Provided an invalid signature. Signature ${t.s} of type ${t.t} by account ${r} is not a valid signature for message ${i}`;let u=!1;try{u=await I.verifySignature(o,i,t,`${s}:${n}`,this.projectId)}catch{u=!1}if(!u)throw new Error(c);const w=`${this.keyserverUrl}/identity`,f={h:{t:"eip4361"},p:e.cacaoPayload,s:t};try{await g.default.post(w,{cacao:f})}catch(p){throw new Error(`Failed to register on keyserver: ${p}`)}const{pubKeyHex:h,privKeyHex:K}=await this.getKeyData(e.privateIdentityKey);return await this.core.crypto.keychain.set(h,K),await this.identityKeys.set(r,{identityKeyPriv:K,identityKeyPub:h,accountId:r}),h}catch(i){throw this.core.logger.error(i),i}}async unregisterIdentity({account:e}){try{const t=Date.now(),r=this.identityKeys.get(e),i=y.composeDidPkh(e),s={iat:t,exp:y.jwtExp(t),iss:y.encodeEd25519Key(r.identityKeyPub),aud:this.keyserverUrl,pkh:i,act:"unregister_identity",sub:"identity_keys"},n=await this.generateIdAuth(e,s),o=`${this.keyserverUrl}/identity`,c=await g.default.delete(o,{data:{idAuth:n}});if(c.status!==200)throw new Error(`Failed to unregister on keyserver ${c.status}`);await this.identityKeys.delete(e,{code:-1,message:`Account ${e} unregistered`})}catch(t){throw this.core.logger.error(t),t}}async resolveIdentity({publicKey:e}){const t=`${this.keyserverUrl}/identity?publicKey=${e.split(":")[2]}`;try{const{data:r}=await g.default.get(t);return r.value.cacao}catch(r){throw this.core.logger.error(r),new Error("Failed to resolve identity key")}}async getIdentity({account:e}){return this.identityKeys.get(e).identityKeyPub}async hasIdentity({account:e}){return this.identityKeys.keys.includes(e)}}class x{}exports.DEFAULT_KEYSERVER_URL=v,exports.IIdentityKeys=x,exports.IdentityKeys=$;
//# sourceMappingURL=index.cjs.js.map
